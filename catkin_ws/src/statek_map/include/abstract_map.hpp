#pragma once

#include <string>
#include <vector>
#include <geometry_msgs/TransformStamped.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>
#include <tf2/transform_datatypes.h>

class AbstractMap
{
    friend class MapFuser;

public:
    /**
     * @brief Values that can be set in map cells.
     */
    enum CellType
    {
        UNKNOWN_CELL = -1,   //!< Robot doesn't know anything about this cell.
        FREE_CELL = 0,       //!< Robot can move onto this cell.
        FILLED_GAP = 90,     //!< This cell was filled by some algorithm and robot shouldn't move onto this cell.
        OBSTACLE_CELL = 100, //!< This cell has some obstacle and robot musn't move onto this cell.

    };

    /**
     * @brief Some parameters for map generation.
     */
    struct MapParams
    {
        double mapSizeMeters;               //!< Dimension of map in meters.
        double cellSizeMeters;              //!< Dimension of one cell in map.
        double minimumGapSizeMetersSquared; //!< Square of minimum gap size that robot can pass.
        unsigned int numCellsPerRowCol;     //!< This MUST be mapSizeMeters / cellSizeMeters. Defines how many elements are in map's rows and columns (map matrix is always a square matrix).
    };

private:
    std::vector<int8_t> mapMatrix;             //!< Contains map generated by inherited classes. This map should be in footprint frame.
    geometry_msgs::TransformStamped transform; //!< Transform from frame_id = footprint to child_frame_id = sensor_frame.
    double xx;                                 // x coefficient to rotate x.
    double xy;                                 // y coefficient to rotate x.
    double xz;                                 // z coefficient to rotate x.
    double yx;                                 // x coefficient to rotate y.
    double yy;                                 // y coefficient to rotate y.
    double yz;                                 // z coefficient to rotate y.
    double zx;                                 // x coefficient to rotate z.
    double zy;                                 // y coefficient to rotate z.
    double zz;                                 // z coefficient to rotate z.

    /**
     * @brief Get rotation matrix coefficients.
     * 
     * These coefficients are used to rotate data from sensors
     * to match footprint's rotation.
     */
    void updateRotationMultipliers()
    {
        tf2::Quaternion quatTf;
        tf2::fromMsg(this->transform.transform.rotation, quatTf);
        quatTf.normalize();

        double roll, pitch, yaw;
        tf2::Matrix3x3(quatTf).getRPY(roll, pitch, yaw);

        // https://en.wikipedia.org/wiki/Rotation_matrix
        this->xx = cos(yaw) * cos(pitch);
        this->xy = cos(yaw) * sin(pitch) * sin(roll) - sin(yaw) * cos(roll);
        this->xz = cos(yaw) * sin(pitch) * cos(roll) + sin(yaw) * sin(roll);

        this->yx = sin(yaw) * cos(pitch);
        this->yy = sin(yaw) * sin(pitch) * sin(roll) + cos(yaw) * cos(roll);
        this->yz = sin(yaw) * sin(pitch) * cos(roll) - cos(yaw) * sin(roll);

        this->zx = -sin(pitch);
        this->zy = cos(pitch) * sin(roll);
        this->zz = cos(pitch) * cos(roll);
    }

    /**
     * @brief Translate point to match footprint's tf link.
     * @param x
     * @param y
     * @param z
     */
    void translateToFootrint(double &x, double &y, double &z)
    {
        x += this->transform.transform.translation.x;
        y += this->transform.transform.translation.y;
        z += this->transform.transform.translation.z;
    }

    /**
     * @brief Rotate point to match fooprint's tf link.
     * @param x
     * @param y
     * @param z
     */
    void rotateToFootprint(double &x, double &y, double &z)
    {
        double xTemp = x;
        double yTemp = y;
        double zTemp = z;

        x = xTemp * this->xx + yTemp * this->xy + zTemp * this->xz;
        y = xTemp * this->yx + yTemp * this->yy + zTemp * this->yz;
        z = xTemp * this->zx + yTemp * this->zy + zTemp * this->zz;
    }

protected:
    static MapParams params; //!< Shared parameters for all object inheriting this class.

    /**
     * @brief Translate then rotate point to match footprint's tf link.
     * @param x
     * @param y
     * @param z
     */
    void transformToFootprint(double &x, double &y, double &z)
    {
        this->translateToFootrint(x, y, z);
        this->rotateToFootprint(x, y, z);
    }

    /**
     * @brief Get iterator to first element of internal vector that stores the map.
     * @return const_iterator.
     */
    virtual std::vector<int8_t>::const_iterator begin() const
    {
        return mapMatrix.begin();
    }

    /**
     * @brief Get iterator to end of internal vector that stores the map.
     * @return const_iterator.
     */
    virtual std::vector<int8_t>::const_iterator end() const
    {
        return mapMatrix.end();
    }

    /**
     * @brief Get element of internal vector that stores the map.
     * @param index Index.
     * @return Value of requested element.
     */
    virtual int8_t operator[](const unsigned int index) const
    {
        return mapMatrix[index];
    }

    /**
     * @brief Set sensor's map cell to given value.
     * @param y Row of map.
     * @param x Column of map.
     * @param val Value to set.
     */
    virtual void set(unsigned int y, unsigned int x, int8_t val)
    {
        mapMatrix[y * params.numCellsPerRowCol + x] = val;
    }

    /**
     * @brief Get value from given cell.
     * @param y Row of map.
     * @param x Column of map.
     * @return Value of cell.
     */
    virtual int8_t get(unsigned int y, unsigned int x) const
    {
        return mapMatrix[y * params.numCellsPerRowCol + x];
    }

    /**
     * @brief Reset map to CellType::UNKNOWN_CELL.
     */
    virtual void reset()
    {
        std::fill(this->mapMatrix.begin(), this->mapMatrix.end(), CellType::UNKNOWN_CELL);
    }

public:
    /**
     * @brief Class constructor. AbstractMap::setParams must be called before this constructor.
     */
    AbstractMap()
    {
        this->resize();
    }

    /**
     * @brief Set map param's. Those params will be accessible to every map generator that inherits AbstractMap.
     * @param _params Params to set.
     */
    static void setParams(const MapParams &_params)
    {
        params = _params;
    }

    /**
     * @brief Convert cartesian distance from sensor(0,0) to index in map matrix (either x or y assuming that map is a square matrix).
     * @param val Cartesian distance from sensor (0,0) in meters.
     * @return Index in map matrix. This index can be out of range so should be checked in advance.
     */
    static int toIndex(double val)
    {
        val /= params.cellSizeMeters;
        val += params.numCellsPerRowCol / 2.0;
        return val;
    }

    /**
     * @brief Convert index in map matrix (either x or y assumind that map is a square matrix) to Cartesian distance from sensor (0,0) in meters.
     * @param idx Index to convert.
     * @return Cartesian distance from sensor.
     */
    static double toMeters(unsigned int idx)
    {
        double result = idx;
        result -= params.numCellsPerRowCol / 2.0;
        return result * params.cellSizeMeters;
    }

    /**
     * @brief Save transform received from tf transform broadcaster.
     * This transform will be used to translate sensor readings onto footprint link.
     * 
     * This expects frame_id of transform to be footprint of the robot
     * and child_frame_id to be desired sensor.
     * 
     * @param _transform Desired transform.
     */
    void setTransform(const geometry_msgs::TransformStamped &_transform)
    {
        this->transform = _transform;

        this->updateRotationMultipliers();
    }

    /**
     * @brief Resizes map to accommodate map matrix after call to AbstractMap::setParams.
     */
    virtual void resize()
    {
        mapMatrix.resize(params.numCellsPerRowCol * params.numCellsPerRowCol);
        this->reset();
    }
};

AbstractMap::MapParams AbstractMap::params = {0, 0, 0, 0};