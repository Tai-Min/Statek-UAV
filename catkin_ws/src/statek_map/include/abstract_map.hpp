#pragma once

#include <vector>
#include <geometry_msgs/TransformStamped.h>

class AbstractMap
{
    friend class MapFuser; //!< This class should've access to internal map of every object to generate fused map.

public:
    /**
     * @brief Values that can be set in map cells.
     */
    enum CellType
    {
        UNKNOWN_CELL = -1,   //!< The robot doesn't know anything about this cell.
        FREE_CELL = 0,       //!< The robot can move onto this cell.
        FILLED_GAP = 90,     //!< This cell was filled by some algorithm and robot shouldn't move onto this cell.
        OBSTACLE_CELL = 100, //!< This cell has some obstacle and robot musn't move onto this cell.
    };

    /**
     * @brief Some parameters for map generation.
     */
    struct MapParams
    {
        double mapSizeMeters;               //!< Dimension of map in meters.
        double cellSizeMeters;              //!< Dimension of one cell in map.
        double minimumGapSizeMetersSquared; //!< Square of minimum gap size that robot can pass.
        unsigned int numCellsPerRowCol;     //!< This MUST be mapSizeMeters / cellSizeMeters. Defines how many elements are in map's rows and columns (map matrix is always a square matrix).
    };

protected:
    typedef std::vector<int8_t> mapType;

private:
    mapType mapMatrix;                         //!< Contains map generated by inherited classes. This map should be in footprint frame.
    geometry_msgs::TransformStamped transform; //!< Some transform to transform incoming data to match some tf link such as footprint.

    double xx; // X coefficient to rotate some point around x.
    double xy; // Y coefficient to rotate some point around x.
    double xz; // Z coefficient to rotate some point around x.
    double yx; // X coefficient to rotate some point around y.
    double yy; // Y coefficient to rotate some point around y.
    double yz; // Z coefficient to rotate some point around y.
    double zx; // X coefficient to rotate some point around z.
    double zy; // Y coefficient to rotate some point around z.
    double zz; // Z coefficient to rotate some point around z.

    /**
     * @brief Update rotation matrix coefficients.
     * 
     * These coefficients are used to rotate data from sensors
     * to match footprint's rotation.
     * This should be called every time this->transform is updated.
     */
    void updateRotationMultipliers();

    /**
     * @brief Translate point using this object's transform.
     * @param x Point to translate and result of translation.
     * @param y Point to translate and result of translation.
     * @param z Point to translate and result of translation.
     */
    void translatePoint(double &x, double &y, double &z);

    /**
     * @brief Rotate point using this object's transform.
     * @param x Point to rotate and result of rotation.
     * @param y Point to rotate and result of rotation.
     * @param z Point to rotate and result of rotation.
     */
    void rotatePoint(double &x, double &y, double &z);

protected:
    static MapParams params; //!< Shared parameters for all object inheriting this class.

    /**
     * @brief Check whether given coordinates are on map.
     * @param y Y.
     * @param x X.
     * @return True if both y and x are in range.
     */
    static bool isValidPoint(int y, int x);

    /**
     * @brief Translate then rotate point using transform passed to this object by setTransform.
     * @param x Point to transform and result of transform.
     * @param y Point to transform and result of transform.
     * @param z Point to transform and result of transform.
     */
    virtual void transformPoint(double &x, double &y, double &z);

    /**
     * @brief Get iterator to first element of internal vector that stores the map.
     * @return const_iterator.
     */
    virtual mapType::const_iterator begin() const;

    /**
     * @brief Get iterator to end of internal vector that stores the map.
     * @return const_iterator.
     */
    virtual mapType::const_iterator end() const;

    /**
     * @brief Get element of internal vector that stores the map.
     * @param index Index.
     * @return Value of requested element.
     */
    virtual int8_t operator[](const unsigned int index) const;

    /**
     * @brief Set sensor's map cell to given value.
     * @param y Row of map.
     * @param x Column of map.
     * @param val Value to set.
     */
    virtual void set(unsigned int y, unsigned int x, int8_t val);

    /**
     * @brief Get value from given cell.
     * @param y Row of map.
     * @param x Column of map.
     * @return Value of cell.
     */
    virtual int8_t get(unsigned int y, unsigned int x) const;

    /**
     * @brief Reset map to CellType::UNKNOWN_CELL.
     */
    virtual void reset();

public:
    /**
     * @brief Class constructor. AbstractMap::setParams must be called before this constructor.
     */
    AbstractMap();

    /**
     * @brief Set map param's. Those params will be accessible to every map generator that inherits AbstractMap.
     * @param _params Params to set.
     */
    static void setParams(const MapParams &_params);

    /**
     * @brief Convert cartesian distance from sensor(0,0) to index in map matrix (either x or y assuming that map is a square matrix).
     * @param val Cartesian distance from sensor (0,0) in meters.
     * @return Index in map matrix. This index can be out of range so should be checked in advance.
     */
    static int toIndex(double val);

    /**
     * @brief Convert index in map matrix (either x or y assuming that map is a square matrix) to Cartesian distance from sensor (0,0) in meters.
     * @param idx Index to convert.
     * @return Cartesian distance from sensor.
     */
    static double toMeters(int idx);

    /**
     * @brief Save transform received from tf transform broadcaster.
     * This transform will be used mostly to translate sensor readings onto footprint link.
     * 
     * @param _transform Desired transform.
     */
    virtual void setTransform(const geometry_msgs::TransformStamped &_transform);

    /**
     * @brief Resizes map to accommodate map matrix after call to AbstractMap::setParams.
     * Use only if AbstractMap::setParams was called after constructor of this object.
     */
    virtual void resize();
};